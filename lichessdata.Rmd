---
title: "R Notebook"
author: "Alex Mangiapane and Sean Stuhlsatz"
output: html_notebook
---

This notebook will be dedicated to an analysis of various ranking system methods on lichess.org data. First, we import the dataset:

```{r}
lichess <- read.csv("games.csv")
```

Let us do some preliminary analysis of this data:

```{r}
summary(lichess)
head(lichess)
```

We now create a new column of data containing the rating difference between the two players. This figure will be calculated as $white rating - black rating$. 

```{r}
rating_dif <- lichess$white_rating - lichess$black_rating
lichess$rating_dif = rating_dif
```

Now, we filter out the unrated games, so that we can track how ratings update. 

```{r}
#Loops through and stores all the indeces of unrated games, then removes them from the dataframe. Stores these rated games in a new dataframe. 
dv <- c()
counter = 1
for(i in 1:nrow(lichess)){
  if(lichess$rated[i] == "FALSE" | lichess$rated[i] == "False"){
    dv[counter] <- i
    counter = counter + 1
  }
}
rated_lichess <- lichess[-dv,]
```

```{r}
#cor(rated_lichess$turns, abs(rated_lichess$rating_dif))
```

We now sort the games by the time they were created so that we can chronologically track ratings. 

```{r}
ordered_lichess <- rated_lichess[order(rated_lichess$created_at),]
```

With the data sorted, we can now apply our ranking system methods to the dataset and compare their performance in predicting outcomes. We start with TrueSkill, where we experiment with various values for $\epsilon$ to see which performs best. First, let us import the TrueSkill update function:

```{r}
vfuncdraw <- function(a, b){
   return((dnorm(-a-b)-dnorm(a-b))/(pnorm(a-b)-pnorm(-a-b)))
}
vfunc <- function(a, b){
   return(dnorm(a-b)/pnorm(a-b))
}
wfuncdraw <- function(a, b){
   return((vfuncdraw(a, b))^2 + ((a-b)*(dnorm(a-b)) + (a+b)*(dnorm(a+b)))/(pnorm(a-b)-pnorm(-a-b)))
}
wfunc <- function(a, b){
   return(vfunc(a, b)*(vfunc(a, b) + a - b))
}
RateTrueskill <- function(games, p_data, eps = 0, beta = 300){
   for(n in 1:nrow(games)){
      c = sqrt(2*beta^2 + p_data[games[n, 1], 2]^2 + p_data[games[n, 2], 2]^2)
      
      if(p_data[n, 3] == 0.5){
         p_data[games[n, 1], 1] = p_data[games[n, 1], 1] + ((p_data[games[n, 1], 2]^2)/c)*vfuncdraw(((p_data[games[n, 1], 1]) - (p_data[games[n, 2], 1]))/c, eps/c)
      
      p_data[games[n, 2], 1] = p_data[games[n, 2], 1] - ((p_data[games[n, 2], 2]^2)/c)*vfuncdraw(((p_data[games[n, 1], 1]) - (p_data[games[n, 2], 1]))/c, eps/c)
      
      p_data[games[n, 1], 2] = p_data[games[n, 1], 2]*(1-(((p_data[games[n, 1], 2])^2)/(c^2))*wfuncdraw((p_data[games[n, 1], 1] - p_data[games[n, 2], 1])/c, eps/c))
      
      p_data[games[n, 2], 2] = p_data[games[n, 2], 2]*(1-(((p_data[games[n, 2], 2])^2)/(c^2))*wfuncdraw((p_data[games[n, 1], 1] - p_data[games[n, 2], 1])/c, eps/c))
      }else{
           p_data[games[n, 1], 1] = p_data[games[n, 1], 1] + ((p_data[games[n, 1], 2]^2)/c)*vfunc(((p_data[games[n, 1], 1]) - (p_data[games[n, 2], 1]))/c, eps/c)
      
      p_data[games[n, 2], 1] = p_data[games[n, 2], 1] - ((p_data[games[n, 2], 2]^2)/c)*vfunc(((p_data[games[n, 1], 1]) - (p_data[games[n, 2], 1]))/c, eps/c)
      
      p_data[games[n, 1], 2] = p_data[games[n, 1], 2]*(1-(((p_data[games[n, 1], 2])^2)/(c^2))*wfunc((p_data[games[n, 1], 1] - p_data[games[n, 2], 1])/c, eps/c))
      
      p_data[games[n, 2], 2] = p_data[games[n, 2], 2]*(1-(((p_data[games[n, 2], 2])^2)/(c^2))*wfunc((p_data[games[n, 1], 1] - p_data[games[n, 2], 1])/c, eps/c))
      }
   }
   return(p_data)
}
```

Now, we loop through the games.

```{r}
#Initializing an empty dataframe to hold players information
usernames <- c()
ratings <- c()
variances <- c()


#Now we loop through games; any time we encounter a new user, we assign them a rating of 1500 and variance of 300. If they then play multiple games, we update these parameters with the trueskill update.

for(n in nrow(ordered_lichess)){
  if(ordered_lichess$white_id[n] %in% usernames == FALSE){
    append(usernames, ordered_lichess$white_id[n])
    append(ratings, 1500)
    append(variances, 300)
  }else{
  }
}
# This loop is incomplete; first, need to figure out why this append function isn't actually adding anything to the empty vectors,  and then figure out how to use RateTrueskill to update the player data as each new game comes in
```

